using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Metrist.Core;
using Newtonsoft.Json;

namespace Metrist.Monitors.AzureDevOpsPipelines
{
    public class MonitorConfig : BaseMonitorConfig
    {
        public MonitorConfig() { }
        public MonitorConfig(BaseMonitorConfig baseCfg) : base(baseCfg) { }

        public string Organization { get; set; }
        public string Project { get; set; }
        public string PersonalAccessToken { get; set; }
        public string PipelineId { get; set; }

        public string ApiRoot
        {
            get
            {
                return $"https://dev.azure.com/{this.Organization}/{this.Project}/_apis/";
            }
        }

        public string PipelineUrl { get { return $"{this.ApiRoot}pipelines/{this.PipelineId}/"; } }
    }

    public class Monitor : BaseMonitor
    {
        private readonly MonitorConfig _config;
        private HttpClient _client;
        private Run _machineWorkflowRun;
        private Run _dockerWorkflowRun;

        public Monitor(MonitorConfig config) : base(config)
        {
            _config = config;
            _client = new HttpClient();
            _client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue(
                "Basic",
                Convert.ToBase64String(Encoding.ASCII.GetBytes($":{_config.PersonalAccessToken}"))
            );
            _client.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json-patch+json"));            
        }

        public async Task StartMachineWorkflow(Logger logger)
        {
            var body = JsonConvert.SerializeObject(

                new
                {
                    stagesToSkip = new string [] {
                        "DockerExecutionRun"
                    }
                }
            );

            _machineWorkflowRun = await DoPost<Run>(body, $"{_config.PipelineUrl}runs?api-version=6.0-preview.1", logger);
        }

        public async Task<double> WaitForMachineWorkflowRunToComplete(Logger logger)
        {
            return await GetRunResult("Machine workflow run", _machineWorkflowRun.id, logger);
        }

        public async Task StartDockerWorkflow(Logger logger)
        {
            var body = JsonConvert.SerializeObject(
                new
                {
                    stagesToSkip = new string [] {
                        "MachineExecutionRun"
                    }
                }
            );

            _dockerWorkflowRun = await DoPost<Run>(body, $"{_config.PipelineUrl}runs?api-version=6.0-preview.1", logger);
        }

        public async Task<double> WaitForDockerWorkflowRunToComplete(Logger logger)
        {
            return await GetRunResult("Docker workflow run", _dockerWorkflowRun.id, logger);
        }

        public void TearDown(Logger logger)
        {
            _client?.Dispose();
        }

        public void Cleanup(Logger logger)
        {
        }        

        private async Task<double> GetRunResult(string name, int runId, Logger logger) 
        {
            Run run = await GetRun(runId, logger);
            while (run.state == "inProgress") 
            {
                // Delaying 5s between queries to not hammer Azure 
                // but it will not impact timing as we will subtract finishedDate from createdDate
                await Task.Delay(5000);
                run = await GetRun(runId, logger);
            }

            if (run.result != "succeeded")
            {
                throw new Exception($"{name} result {run.result}");
            }

            return (run.finishedDate - run.createdDate).TotalMilliseconds;
        }

        private async Task<Run> GetRun(int runId, Logger logger)
        {
            var response = await _client.GetAsync($"{_config.PipelineUrl}/runs/{runId}");
            response.EnsureSuccessStatusCode();

            var content = await response.Content.ReadAsStringAsync();
            logger(content);
            return JsonConvert.DeserializeObject<Run>(content);
        }

        private async Task<R> DoPost<R>(string jsonBody, string url, Logger logger)
        {
            logger(url);
            logger(jsonBody);
            var response = await _client.PostAsync(
                url,
                new StringContent(jsonBody, Encoding.UTF8, "application/json")
            );
            response.EnsureSuccessStatusCode();

            var content = await response.Content.ReadAsStringAsync();
            logger(content);
            return JsonConvert.DeserializeObject<R>(content);
        }
    }

    #region AutoGenerated JSON Deserialization Objects

    internal class Self
    {
        public string href { get; set; }
        public Repository repository { get; set; }
        public string refName { get; set; }
        public string version { get; set; }
    }

    internal class Web
    {
        public string href { get; set; }
    }

    internal class PipelineWeb
    {
        public string href { get; set; }
    }

    internal class Pipeline
    {
        public string href { get; set; }
        public string url { get; set; }
        public int id { get; set; }
        public int revision { get; set; }
        public string name { get; set; }
        public string folder { get; set; }
    }

    internal class Links
    {
        public Self self { get; set; }
        public Web web { get; set; }

        [JsonProperty("pipeline.web")]
        public PipelineWeb PipelineWeb { get; set; }
        public Pipeline pipeline { get; set; }
    }

    internal class Connection
    {
        public string id { get; set; }
    }

    internal class Repository
    {
        public string fullName { get; set; }
        public Connection connection { get; set; }
        public string type { get; set; }
    }

    internal class Repositories
    {
        public Self self { get; set; }
    }

    internal class Resources
    {
        public Repositories repositories { get; set; }
    }

    internal class Run
    {
        public Links _links { get; set; }
        public Pipeline pipeline { get; set; }
        public string state { get; set; }
        public DateTime createdDate { get; set; }
        public DateTime finishedDate { get; set; }
        public string url { get; set; }
        public Resources resources { get; set; }
        public string result { get; set; }
        public int id { get; set; }
        public string name { get; set; }
    }

    #endregion
}
